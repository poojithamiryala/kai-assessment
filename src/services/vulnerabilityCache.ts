import type { OptimizedVulnerability } from '../types/vulnerability';
import { EfficientDataProcessor } from '../utils/efficientDataProcessor';

/**
 * Interface defining the structure of cached vulnerability data
 * Contains all necessary data to restore the application state without reprocessing
 */
interface CachedVulnerabilityData {
  vulnerabilities: OptimizedVulnerability[];
  dataProcessor: EfficientDataProcessor;
  performanceStats: {
    totalVulnerabilities: number;
    severityBreakdown: Record<string, number>;
    kaiStatusBreakdown: Record<string, number>;
  };
  timestamp: number; // Unix timestamp when cache was created
  version: string; // Cache version for compatibility checks
}

/**
 * Singleton cache service for vulnerability data
 * 
 * Purpose:
 * - Reduces processing time by storing pre-processed vulnerability data
 * - Enables instant tab switching after initial load
 * - Prevents redundant data processing across component mounts
 * 
 * Features:
 * - Automatic expiration (5 minutes)
 * - Version control for cache invalidation
 * - Memory-efficient storage of processed data
 * - Thread-safe operations
 */
class VulnerabilityCache {
  private cache: CachedVulnerabilityData | null = null;
  private readonly CACHE_DURATION = 5 * 60 * 1000; // 5 minutes in milliseconds
  private readonly CACHE_VERSION = '1.0.0'; // Increment when data structure changes

  /**
   * Validates cache integrity and expiration
   * 
   * @returns true if cache exists, is not expired, and version matches
   * @returns false if cache is missing, expired, or version mismatch
   */
  private isCacheValid(): boolean {
    if (!this.cache) return false;
    
    const now = Date.now();
    const isNotExpired = (now - this.cache.timestamp) < this.CACHE_DURATION;
    const isCorrectVersion = this.cache.version === this.CACHE_VERSION;
    
    return isNotExpired && isCorrectVersion;
  }

  /**
   * Retrieves cached vulnerability data if valid
   * 
   * This method is the primary way to access cached data. It performs
   * validation checks before returning the cache to ensure data integrity.
   * 
   * @returns CachedVulnerabilityData if cache is valid and not expired
   * @returns null if no cache exists or cache is invalid/expired
   */
  getCachedData(): CachedVulnerabilityData | null {
    if (this.isCacheValid()) {
      return this.cache;
    }
    
    return null;
  }

  /**
   * Stores processed vulnerability data in cache
   * 
   * This method should be called after successful data processing to enable
   * instant loading on subsequent component mounts or tab switches.
   * 
   * @param vulnerabilities - Array of processed vulnerability objects
   * @param dataProcessor - EfficientDataProcessor instance with built indexes
   * @param performanceStats - Pre-calculated metrics and statistics
   */
  setCachedData(
    vulnerabilities: OptimizedVulnerability[],
    dataProcessor: EfficientDataProcessor,
    performanceStats: {
      totalVulnerabilities: number;
      severityBreakdown: Record<string, number>;
      kaiStatusBreakdown: Record<string, number>;
    }
  ): void {
    this.cache = {
      vulnerabilities,
      dataProcessor,
      performanceStats,
      timestamp: Date.now(),
      version: this.CACHE_VERSION
    };
  }

  /**
   * Clears the current cache and frees memory
   * 
   * This method removes all cached data, forcing the next data access
   * to trigger fresh processing. Useful for manual refresh operations
   * or when data needs to be reloaded.
   */
  clearCache(): void {
    this.cache = null;
  }

  /**
   * Provides detailed cache information for debugging and monitoring
   * 
   * Returns comprehensive cache status including existence, validity,
   * age, and size. Useful for debugging cache behavior and monitoring
   * cache performance.
   * 
   * @returns Object containing cache metadata
   */
  getCacheInfo(): {
    hasCache: boolean;
    isValid: boolean;
    age: number;
    size: number;
  } {
    if (!this.cache) {
      return {
        hasCache: false,
        isValid: false,
        age: 0,
        size: 0
      };
    }

    return {
      hasCache: true,
      isValid: this.isCacheValid(),
      age: Date.now() - this.cache.timestamp,
      size: this.cache.vulnerabilities.length
    };
  }

  /**
   * Forces cache refresh by clearing current cache
   * 
   * This method is a convenience wrapper around clearCache() that provides
   * semantic clarity for refresh operations. It ensures the next data access
   * will trigger fresh processing regardless of cache validity.
   */
  forceRefresh(): void {
    this.clearCache();
  }
}

/**
 * Singleton instance of VulnerabilityCache
 * 
 * This instance is shared across the entire application, ensuring
 * consistent cache behavior and preventing multiple cache instances
 * from conflicting with each other.
 */
export const vulnerabilityCache = new VulnerabilityCache();
