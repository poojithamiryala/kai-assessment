import type { 
  VulnerabilityData, 
  DataMetrics, 
  OptimizedVulnerability
} from '../types/vulnerability';

// Efficient data processor class - Storing only the necessary fields to avoid memory issues
export class VulnerabilityProcessor {
  // Using Map to store vulnerabilities
  private vulnerabilities: Map<string, OptimizedVulnerability> = new Map();
  // Using Record to store metrics
  private metrics: DataMetrics;
  // Pre-calculating filtered metrics
  private analysisFilteredMetrics: DataMetrics;
  private aiAnalysisFilteredMetrics: DataMetrics;
  
  // Sets to track filtered vulnerability IDs
  private analysisFilteredIds: Set<string> = new Set();
  private aiAnalysisFilteredIds: Set<string> = new Set();
  // Pre-calculated trend data - using month -> severity -> count mapping
  private discoveryTrendData: Record<string, Record<string, number>> = {};
  private fixTrendData: Record<string, Record<string, number>> = {};

  constructor() {
    // Initializing metrics
    this.metrics = {
      totalVulnerabilities: 0,
      severityDistribution: {},
      kaiStatusDistribution: {},
      riskFactorDistribution: {},
      groupCount: 0,
      repoCount: 0,
      imageCount: 0,
      discoveryTrend: {},
      fixTrend: {},
    };
    
    // Initialize pre-calculating filtered metrics
    this.analysisFilteredMetrics = {
      totalVulnerabilities: 0,
      severityDistribution: {},
      kaiStatusDistribution: {},
      riskFactorDistribution: {},
      groupCount: 0,
      repoCount: 0,
      imageCount: 0,
      discoveryTrend: {},
      fixTrend: {},
    };
    
    this.aiAnalysisFilteredMetrics = {
      totalVulnerabilities: 0,
      severityDistribution: {},
      kaiStatusDistribution: {},
      riskFactorDistribution: {},
      groupCount: 0,
      repoCount: 0,
      imageCount: 0,
      discoveryTrend: {},
      fixTrend: {},
    };
  }

  // Process raw data into optimized structure
  async processRawData(
    rawData: VulnerabilityData,
    onProgress?: (progress: number) => void
  ): Promise<void> {
    console.log('Processing vulnerability data with optimized structures...');
    
    // Initializing sets to track unique counts
    const uniqueGroups = new Set<string>();
    const uniqueRepos = new Set<string>();
    const uniqueImages = new Set<string>();

    // Initializing records to track severity and kai status distribution
    const severityDistribution: Record<string, number> = {};
    const kaiStatusDistribution: Record<string, number> = {};
    const riskFactorDistribution: Record<string, number> = {};
    
    // Pre-calculating filtered metrics
    const analysisSeverityDistribution: Record<string, number> = {};
    const analysisKaiStatusDistribution: Record<string, number> = {};
    const analysisRiskFactorDistribution: Record<string, number> = {};
    const analysisUniqueGroups = new Set<string>();
    const analysisUniqueRepos = new Set<string>();
    const analysisUniqueImages = new Set<string>();
    
    const aiAnalysisSeverityDistribution: Record<string, number> = {};
    const aiAnalysisKaiStatusDistribution: Record<string, number> = {};
    const aiAnalysisRiskFactorDistribution: Record<string, number> = {};
    const aiAnalysisUniqueGroups = new Set<string>();
    const aiAnalysisUniqueRepos = new Set<string>();
    const aiAnalysisUniqueImages = new Set<string>();
    
    // Initializing processed count and total groups
    let processedCount = 0;
    let analysisFilteredCount = 0;
    let aiAnalysisFilteredCount = 0;
    const totalGroups = Object.values(rawData.groups).length;
    
    // Processing data
    for (const group of Object.values(rawData.groups)) {
      for (const repo of Object.values(group.repos)) {
        for (const image of Object.values(repo.images)) {
          for (const vuln of image.vulnerabilities) {
            // Create single hash-based ID for simplicity and performance
            const vulnId = `${group.name}/${repo.name}/${image.name}/${vuln.cve}/${vuln.packageName}/${vuln.packageVersion}/${vuln.published}/${vuln.fixDate}/${vuln.status}`;
            
            // Create optimized vulnerability object
            const optimizedVuln: OptimizedVulnerability = {
              id: vulnId,
              cve: vuln.cve,
              severity: vuln.severity || 'unknown',
              kaiStatus: vuln.kaiStatus || 'unknown',
              published: vuln.published || '',
              fixDate: vuln.fixDate || '',
              description: vuln.description || '',
              groupName: group.name,
              repoName: repo.name,
              imageName: image.name,
              imageVersion: image.version || '',
              baseImage: image.baseImage,
              buildType: image.buildType,
              maintainer: image.maintainer,
              createTime: image.createTime,
              riskFactors: vuln.riskFactors || {},
              // Pre-computing fields for efficient filtering
              severityScore: this.getSeverityScore(vuln.severity || 'unknown'),
              isHighRisk: this.isHighRisk(vuln.severity || 'unknown'),
              isKaiFiltered: this.isKaiFiltered(vuln.kaiStatus || 'unknown'),
            };
            
            // Storing in main collection
            this.vulnerabilities.set(vulnId, optimizedVuln);
            
            // Update severity, kai status, and risk factor metrics
            this.updateMetrics(optimizedVuln, severityDistribution, kaiStatusDistribution, riskFactorDistribution);
            
            // Collect trend data
            this.collectTrendData(optimizedVuln);
            
            // Tracking unique counts
            uniqueGroups.add(group.name);
            uniqueRepos.add(`${group.name}/${repo.name}`);
            uniqueImages.add(`${group.name}/${repo.name}/${image.name}`);
            
            // Pre-calculate analysis filter metrics (exclude 'invalid - norisk')
            if (optimizedVuln.kaiStatus === 'invalid - norisk') {
              analysisFilteredCount++;
              this.analysisFilteredIds.add(vulnId);
              this.updateMetrics(optimizedVuln, analysisSeverityDistribution, analysisKaiStatusDistribution, analysisRiskFactorDistribution);
              analysisUniqueGroups.add(group.name);
              analysisUniqueRepos.add(`${group.name}/${repo.name}`);
              analysisUniqueImages.add(`${group.name}/${repo.name}/${image.name}`);
            }
            
            // Pre-calculate AI analysis filter metrics (exclude 'ai-invalid-norisk')
            if (optimizedVuln.kaiStatus === 'ai-invalid-norisk') {
              aiAnalysisFilteredCount++;
              this.aiAnalysisFilteredIds.add(vulnId);
              this.updateMetrics(optimizedVuln, aiAnalysisSeverityDistribution, aiAnalysisKaiStatusDistribution, aiAnalysisRiskFactorDistribution);
              aiAnalysisUniqueGroups.add(group.name);
              aiAnalysisUniqueRepos.add(`${group.name}/${repo.name}`);
              aiAnalysisUniqueImages.add(`${group.name}/${repo.name}/${image.name}`);
            }
            
            processedCount++;
            
            // Reporting progress
            if (processedCount % 1000 === 0) {
              await new Promise(resolve => setTimeout(resolve, 0));
              if (onProgress) {
                const progress = Math.round((processedCount / (totalGroups * 10)) * 100);
                onProgress(Math.min(progress, 95));
              }
            }
          }
        }
      }
    }
    
    // Finalizing metrics
    this.metrics = {
      totalVulnerabilities: processedCount,
      severityDistribution,
      kaiStatusDistribution,
      riskFactorDistribution,
      groupCount: uniqueGroups.size,
      repoCount: uniqueRepos.size,
      imageCount: uniqueImages.size,
      discoveryTrend: this.discoveryTrendData,
      fixTrend: this.fixTrendData,
    };
    
    // Finalizing pre-calculating filtered metrics
    this.analysisFilteredMetrics = {
      totalVulnerabilities: analysisFilteredCount,
      severityDistribution: analysisSeverityDistribution,
      kaiStatusDistribution: analysisKaiStatusDistribution,
      riskFactorDistribution: analysisRiskFactorDistribution,
      groupCount: analysisUniqueGroups.size,
      repoCount: analysisUniqueRepos.size,
      imageCount: analysisUniqueImages.size,
      discoveryTrend: this.discoveryTrendData, // Same trend data for now
      fixTrend: this.fixTrendData,
    };
    
    this.aiAnalysisFilteredMetrics = {
      totalVulnerabilities: aiAnalysisFilteredCount,
      severityDistribution: aiAnalysisSeverityDistribution,
      kaiStatusDistribution: aiAnalysisKaiStatusDistribution,
      riskFactorDistribution: aiAnalysisRiskFactorDistribution,
      groupCount: aiAnalysisUniqueGroups.size,
      repoCount: aiAnalysisUniqueRepos.size,
      imageCount: aiAnalysisUniqueImages.size,
      discoveryTrend: this.discoveryTrendData, // Same trend data for now
      fixTrend: this.fixTrendData,
    };
    
    if (onProgress) {
      onProgress(100);
    }
    
    console.log('Data processing completed!');
    console.log('Total vulnerabilities:', this.metrics.totalVulnerabilities);
  }

  // Updating metrics incrementally
  private updateMetrics(
    vuln: OptimizedVulnerability,
    severityDistribution: Record<string, number>,
    kaiStatusDistribution: Record<string, number>,
    riskFactorDistribution: Record<string, number>
  ): void {
    severityDistribution[vuln.severity] = (severityDistribution[vuln.severity] || 0) + 1;
    kaiStatusDistribution[vuln.kaiStatus] = (kaiStatusDistribution[vuln.kaiStatus] || 0) + 1;
    
    // Extract risk factors from vulnerability riskFactors field
    const riskFactors = this.extractRiskFactor(vuln);
    riskFactors.forEach(riskFactor => {
      riskFactorDistribution[riskFactor] = (riskFactorDistribution[riskFactor] || 0) + 1;
    });
  }

  // Extract risk factor from vulnerability data using riskFactors field
  private extractRiskFactor(vuln: OptimizedVulnerability): string[] {
    // Use the riskFactors field directly from the CVE data
    if (vuln.riskFactors && Object.keys(vuln.riskFactors).length > 0) {
      return Object.keys(vuln.riskFactors);
    }
    
    // Fallback: return empty array if no risk factors
    return [];
  }

  // Collect trend data during processing
  private collectTrendData(vuln: OptimizedVulnerability): void {
    // Discovery trend (published date)
    if (vuln.published) {
      const month = this.normalizeDateToMonth(vuln.published);
      if (!this.discoveryTrendData[month]) {
        this.discoveryTrendData[month] = {
          critical: 0,
          high: 0,
          medium: 0,
          low: 0,
        };
      }
      this.discoveryTrendData[month][vuln.severity] = (this.discoveryTrendData[month][vuln.severity] || 0) + 1;
    }
    
    // Fix trend (fixDate)
    if (vuln.fixDate) {
      const month = this.normalizeDateToMonth(vuln.fixDate);
      if (!this.fixTrendData[month]) {
        this.fixTrendData[month] = {
          critical: 0,
          high: 0,
          medium: 0,
          low: 0,
        };
      }
      this.fixTrendData[month][vuln.severity] = (this.fixTrendData[month][vuln.severity] || 0) + 1;
    }
    
  }

  // Get severity score for sorting
  private getSeverityScore(severity: string): number {
    const scores = { critical: 5, high: 4, medium: 3, low: 2, info: 1, unknown: 0 };
    return scores[severity.toLowerCase() as keyof typeof scores] || 0;
  }

  // Checking if vulnerability is high risk
  private isHighRisk(severity: string): boolean {
    return ['critical', 'high'].includes(severity.toLowerCase());
  }

  // Checking if vulnerability should be filtered by Kai
  private isKaiFiltered(kaiStatus: string): boolean {
    return ['invalid - norisk', 'ai-invalid-norisk'].includes(kaiStatus);
  }

  // Getting the vulnerabilities
  public getVulnerabilities(): OptimizedVulnerability[] {
    return Array.from(this.vulnerabilities.values());
  }

  // Getting the metrics
  public getMetrics(): DataMetrics {
    return this.metrics;
  }

  // Get pre-calculating analysis filtered metrics (with 'invalid - norisk' Kai filter)
  public getAnalysisFilteredMetrics(): DataMetrics {
    return this.analysisFilteredMetrics;
  }

  // Get pre-calculating AI analysis filtered metrics (with 'ai-invalid-norisk' Kai filter)
  public getAiAnalysisFilteredMetrics(): DataMetrics {
    return this.aiAnalysisFilteredMetrics;
  }

  // Get analysis filtered vulnerability IDs
  public getAnalysisFilteredIds(): Set<string> {
    return this.analysisFilteredIds;
  }

  // Get AI analysis filtered vulnerability IDs
  public getAiAnalysisFilteredIds(): Set<string> {
    return this.aiAnalysisFilteredIds;
  }

  // Get discovery trend data (CVEs published over time) - now using precalculated data
  public getDiscoveryTrend(): Record<string, Record<string, number>> {
    return this.discoveryTrendData;
  }

  // Get fix trend data (CVEs fixed over time) - now using precalculated data
  public getFixTrend(): Record<string, Record<string, number>> {
    return this.fixTrendData;
  }

  // Normalize date to YYYY-MM format
  private normalizeDateToMonth(dateString: string): string {
    try {
      const date = new Date(dateString);
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      return `${year}-${month}`;
    } catch (error) {
      console.warn('Invalid date format:', dateString);
      return 'unknown';
    }
  }


}

// Factory function to create processor
export const createVulnerabilityProcessor = (): VulnerabilityProcessor => {
  return new VulnerabilityProcessor();
};
