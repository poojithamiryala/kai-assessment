import { useState, useEffect, useCallback, useRef } from 'react';
import { useVulnerabilityData } from './useVulnerabilityData';
import { vulnerabilityCache } from '../services/vulnerabilityCache';
import type { OptimizedVulnerability } from '../types/vulnerability';
import { EfficientDataProcessor } from '../utils/efficientDataProcessor';

/**
 * Interface defining what this hook returns to components
 * This makes it clear what data and functions are available
 */
interface AsyncVulnerabilityData {
  vulnerabilities: OptimizedVulnerability[]; // The processed vulnerability data
  dataProcessor: EfficientDataProcessor | null; // Smart processor for fast searching/filtering
  performanceStats: any; // Metrics about the data (counts, distributions, etc.)
  isLoading: boolean; // Whether we're still loading or processing data
  error: Error | null; // Any errors that occurred during loading
  progress: number; // Loading progress (0-100)
  isStreaming: boolean; // Whether data is still being streamed from server
  refreshData: () => void; // Function to force refresh the data
  clearCache: () => void; // Function to clear the cache and free memory
  cacheInfo: {
    hasCache: boolean; // Whether we have cached data available
    isValid: boolean; // Whether the cache is still fresh and valid
    age: number; // How old the cache is (in milliseconds)
    size: number; // How many vulnerabilities are in the cache
  };
}

/**
 * useAsyncVulnerabilityData Hook
 * 
 * This is a smart hook that handles loading, processing, and caching vulnerability data.
 * It's designed to make the app feel fast and responsive, even with huge datasets.
 * 
 * Key Features:
 * - Loads raw data from the server asynchronously
 * - Processes data in the background without blocking the UI
 * - Caches processed data for instant loading on subsequent visits
 * - Provides loading states and error handling
 * - Offers cache management functions for manual control
 * 
 * How it works:
 * 1. Gets raw data from useVulnerabilityData hook
 * 2. Checks if we have cached processed data first
 * 3. If no cache, processes data asynchronously in the background
 * 4. Stores processed data in cache for future use
 * 5. Returns processed data and utility functions to components
 */
export const useAsyncVulnerabilityData = (): AsyncVulnerabilityData => {
  // Get raw data from the basic vulnerability data hook
  const { data, isLoading: rawIsLoading, error, progress, isStreaming } = useVulnerabilityData();
  
  // State for tracking if we're currently processing data
  const [isProcessing, setIsProcessing] = useState(false);
  
  // State for storing the processed data (vulnerabilities + processor + stats)
  const [processedData, setProcessedData] = useState<{
    vulnerabilities: OptimizedVulnerability[];
    dataProcessor: EfficientDataProcessor | null;
    performanceStats: any;
  } | null>(null);
  
  // Ref to track if we've already processed data (prevents infinite loops)
  const hasProcessedRef = useRef(false);

  /**
   * Processes raw vulnerability data asynchronously
   * 
   * This function does the heavy lifting of converting raw data into
   * a format that's optimized for fast searching and filtering.
   * It runs in the background so it doesn't block the UI.
   * 
   * Performance Strategy:
   * 1. Cache-first approach - check cache before processing
   * 2. Defer heavy work using setTimeout to prevent UI blocking
   * 3. Wait for EfficientDataProcessor indexing to complete
   * 4. Store results in cache for instant future access
   * 
   * Steps:
   * 1. Check if we have cached data first (fast path)
   * 2. If no cache, process the raw data
   * 3. Create a smart data processor with indexes
   * 4. Calculate performance statistics
   * 5. Cache everything for future use
   */
  const processDataAsync = useCallback(async () => {
    if (!data?.processor) return;

    setIsProcessing(true);
    
    try {
      // First, check if we already have processed data in cache
      // This is the fastest path - no processing needed
      const cachedData = vulnerabilityCache.getCachedData();
      if (cachedData) {
        // Use cached data - this is super fast!
        setProcessedData({
          vulnerabilities: cachedData.vulnerabilities,
          dataProcessor: cachedData.dataProcessor,
          performanceStats: cachedData.performanceStats
        });
        setIsProcessing(false);
        return;
      }

      // No cache found, so we need to process the data
      // Defer this heavy work to prevent UI blocking
      // Use setTimeout to defer heavy processing to the next tick
      // This prevents blocking the main thread
      await new Promise(resolve => setTimeout(resolve, 0));
      
      // Convert the raw vulnerability data into our optimized format
      const vulnerabilities: OptimizedVulnerability[] = Array.from(data.processor.vulnerabilities.values());
      
      // Create our smart data processor - this builds indexes for fast searching
      const dataProcessor = new EfficientDataProcessor(vulnerabilities);
      
      // Wait a bit for the indexing to complete in the background
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Calculate some useful statistics about the data
      const performanceStats = {
        totalVulnerabilities: data.metrics.totalVulnerabilities,
        severityBreakdown: data.metrics.severityDistribution,
        kaiStatusBreakdown: data.metrics.kaiStatusDistribution,
      };

      // Store everything in cache so next time it loads instantly
      vulnerabilityCache.setCachedData(vulnerabilities, dataProcessor, performanceStats);

      // Update our state with the processed data
      setProcessedData({
        vulnerabilities,
        dataProcessor,
        performanceStats
      });
    } catch (err) {
      console.error('Error processing vulnerability data:', err);
    } finally {
      setIsProcessing(false);
    }
  }, [data]);

  /**
   * Main effect that runs when data becomes available
   * 
   * This effect is responsible for triggering data processing when:
   * 1. Raw data first becomes available from the server
   * 2. We haven't already processed this data (prevents infinite loops)
   * 
   * It checks cache first, and if no cache exists, starts processing.
   */
  useEffect(() => {
    // Only run once when data becomes available
    if (!data?.processor || hasProcessedRef.current) return;
    
    // Check if we have cached data first (this is the fast path)
    const cachedData = vulnerabilityCache.getCachedData();
    if (cachedData) {
      // Load from cache instantly - no processing needed!
      setProcessedData({
        vulnerabilities: cachedData.vulnerabilities,
        dataProcessor: cachedData.dataProcessor,
        performanceStats: cachedData.performanceStats
      });
      hasProcessedRef.current = true;
      return;
    }

    // No cache found, so we need to process the data
    processDataAsync();
    hasProcessedRef.current = true;
  }, [data?.processor, processDataAsync]);

  /**
   * Forces a complete refresh of the data
   * 
   * This function is useful when:
   * - User wants to get the latest data from the server
   * - Cache has become stale or corrupted
   * - User manually requests a refresh
   * 
   * It clears the cache and reprocesses everything from scratch.
   */
  const refreshData = useCallback(() => {
    // Force the cache to refresh (mark as invalid)
    vulnerabilityCache.forceRefresh();
    // Clear our processed data
    setProcessedData(null);
    // Reset the processing flag so we can process again
    hasProcessedRef.current = false;
    // If we have raw data, start processing it
    if (data?.processor) {
      processDataAsync();
    }
  }, [data, processDataAsync]);

  /**
   * Clears the cache and frees up memory
   * 
   * This function is useful when:
   * - User wants to free up memory
   * - Debugging cache issues
   * - Starting fresh without any cached data
   * 
   * Note: This will cause the next data access to reprocess everything.
   */
  const clearCache = useCallback(() => {
    // Clear the cache completely
    vulnerabilityCache.clearCache();
    // Clear our processed data
    setProcessedData(null);
    // Reset the processing flag
    hasProcessedRef.current = false;
  }, []);

  // Return all the data and functions that components need
  return {
    // The processed vulnerability data (empty array if still loading)
    vulnerabilities: processedData?.vulnerabilities || [],
    // The smart data processor for fast searching (null if still loading)
    dataProcessor: processedData?.dataProcessor || null,
    // Performance statistics about the data (null if still loading)
    performanceStats: processedData?.performanceStats || null,
    // Whether we're still loading raw data OR processing it
    isLoading: rawIsLoading || isProcessing,
    // Any errors from loading raw data
    error,
    // Loading progress from the raw data hook
    progress,
    // Whether data is still being streamed from server
    isStreaming,
    // Function to force refresh the data
    refreshData,
    // Function to clear the cache
    clearCache,
    // Information about the current cache state
    cacheInfo: vulnerabilityCache.getCacheInfo()
  };
};
